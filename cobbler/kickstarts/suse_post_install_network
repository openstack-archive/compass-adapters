# Start post_install_network_config generated code
#if $getVar('promisc_nics', '') != ""
    #set promisc_interfaces = [promisc.strip() for promisc in $promisc_nics.split(',') if promisc.strip()]
#else
    #set promisc_interfaces = []
#end if

#if $gateway != ""
# set the gateway in the network configuration file
echo "default $gateway - -" > /etc/sysconfig/network/routes
#end if

#if $hostname != ""
# set the hostname in the network configuration file
/bin/hostname $hostname
#end if

$SNIPPET('suse_hosts')

## #set $num_ns_search = $len($name_servers_search)
## #if $num_ns_search > 0
## sed -i -e "/^search /d" /etc/resolv.conf
## echo -n "search " >>/etc/resolv.conf
##         #for $nameserversearch in $name_servers_search
## echo -n "$nameserversearch " >>/etc/resolv.conf
##         #end for
## echo "" >>/etc/resolv.conf
## #end if

## #set $num_ns = $len($name_servers)
## #if $num_ns > 0
## sed -i -e "/^nameserver /d" /etc/resolv.conf
##     #for $nameserver in $name_servers
## echo "nameserver $nameserver" >>/etc/resolv.conf
##     #end for
## #end if

# get physical interfaces
declare -a physical_interfaces
physical_interfaces=()
set \$(ip -o link | grep -v lo | awk '{print \$2}' | sed 's/://')
let physical_interface_num=\$#;
let physical_interface_offset=0
echo "network interface numbers: \$physical_interface_num" > /tmp/network_log
echo "got network interfaces: \$@" >> /tmp/network_log
while [ \$physical_interface_offset -lt \$physical_interface_num ];
do
    physical_interface=\$1
    echo "record \$physical_interface_offset physical interface \${physical_interface}" >> /tmp/network_log
    physical_interfaces+=(\${physical_interface})
    eval "physical_interface_\${physical_interface}=\${physical_interface}"
    let physical_interface_offset=\$physical_interface_offset+1
    shift 1
done

echo "interfaces: \${physical_interfaces[@]}" >> /tmp/network_log

# map physical interface to mac address
declare -a mac_names
mac_names=()
for physical_interface in \${physical_interfaces[@]}; do
    mac=\$(cat /sys/class/net/\${physical_interface}/address)
    mac_name=\$(echo \${mac} |tr 'a-z' 'A-Z' | tr ':' '_')
    mac_names+=(\$mac_name)
    echo "mapping physical interface \${physical_interface} to mac \${mac}" >> /tmp/network_log
    eval "physical_interface_mac_\${physical_interface}=\$mac"
    eval "physical_mac_interface_\${mac_name}=\${physical_interface}"
    eval "mac_name_\${mac_name}=\$mac"
done

echo "list physical interfaces to mac" >> /tmp/network_log
for physical_interface in \${physical_interfaces[@]}; do
    eval "mac=\\${physical_interface_mac_\${physical_interface}}"
    echo "physical interface to mac: \${physical_interface} => \${mac}" >> /tmp/network_log
done

echo "list mac to physical interface mapping" >> /tmp/network_log
for mac_name in \${mac_names[@]}; do
    eval "mac=\\${mac_name_\${mac_name}}"
    eval "physical_interface=\\${physical_mac_interface_\${mac_name}}"
    echo "mac to physical interface: \${mac} => \${physical_interface}" >> /tmp/network_log
done

declare -a logical_interfaces
logical_interfaces=()
#set ikeys = $interfaces.keys()
#set osversion = $getVar("os_version","")
#import re
#set $vlanpattern = $re.compile("([a-zA-Z0-9]+)[\.][0-9]+")
#set $subinterfacepattern = $re.compile("([a-zA-Z0-9]+)[:][0-9]+")
#set $numbondingdevs = 0
#for $iname in $ikeys
    #set $idata = $interfaces[$iname]
    #set $mac = $idata.get("mac_address", "").upper()
    #set $interface_type = $idata.get("interface_type", "").lower()
    #if $interface_type in ("master","bond","bonded_bridge_slave")
        #set $numbondingdevs += 1
    #end if
    #if $interface_type in ("master","bond","bridge","bonded_bridge_slave")
        #continue
    #end if
    #if $vlanpattern.match($iname)
        #set $interface_matched = $vlanpattern.match($iname)
        #set $interface_name = $interface_matched.group(1)
logical_interface=${interface_name}
    #elif $subinterfacepattern.match($iname)
        #set $interface_matched = $subinterfacepattern.match($iname)
        #set $interface_name = $interface_matched.group(1)
logical_interface=${interface_name}
    #else
logical_interface=$iname
    #end if
logical_interfaces+=(\${logical_interface})
eval "logical_interface_\${logical_interface}=\${logical_interface}"
    #if $mac != ""
        #set mac_name = $mac.replace(':', '_')
physical_interface=\${physical_mac_interface_${mac_name}}
eval "logical_interface_mapping_\${logical_interface}=\${physical_interface}"
if [ ! -z "\$physical_interface" ]; then
    eval "physical_interface_mapping_\${physical_interface}=\${logical_interface}"
fi
    #else
eval "physical_interface=\\${logical_interface_mapping_\${logical_interface}}"
if [ -z "\${physical_interface}" ]; then
    eval "logical_interface_mapping_\${logical_interface}="
fi
    #end if
#end for

echo "logical interfaces: \${logical_interfaces[@]}" >> /tmp/network_log

echo "finish mapping logical interfaces in network config to physical interfaces" >> /tmp/network_log
for key in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${key}}"
    echo "map logical interface \${key} to physical interface \${physical_interface}" >> /tmp/network_log
done
for key in \${physical_interfaces[@]}; do
    eval "logical_interface=\\${physical_interface_mapping_\${key}}"
    echo "map physical interface \${key} to logical interface \${logical_interface}" >> /tmp/network_log
done

# map unmapped logical interface to the same name physical interface
echo "mapping unmapped logical interfaces to the same name physical interfaces" >> /tmp/network_log
for logical_interface in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${logical_interface}}"
    if [ ! -z "\${physical_interface}" ]; then
        echo "ignore logical interface \${logical_interface} where its physical interface is \${physical_interface}" >> /tmp/network_log
        continue
    fi
    # check if the same name physical interface is mapped
    eval "mapped_logical_interface=\\${physical_interface_mapping_\${logical_interface}}"
    if [ ! -z "\${mapped_logical_interface}" ]; then
        echo "ignore logical interface \${logical_interface} since the same name physical interface is mapped by logical interface \${mapped_logical_interface}" >> /tmp/network_log
	continue
    fi
    # check if the same name physical interface exists
    eval "mapped_logical_interface=\\${physical_interface_\${logical_interface}}"
    if [ -z "\${mapped_logical_interface}" ]; then
        echo "ignore logical interface \${logical_interface} since the same name physical interface does not exist" >> /tmp/network_log
	continue
    fi
    eval "logical_interface_mapping_\${logical_interface}=\${logical_interface}"
    eval "physical_interface_mapping_\${logical_interface}=\${logical_interface}"
    echo "set logical interface \${logical_interface} to the same physical interface" >> /tmp/network_log
done

echo "finish mapping unmapped logical interfaces in network config to the same name physical interfaces" >> /tmp/network_log
for key in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${key}}"
    echo "map logical interface \${key} to physical interface \${physical_interface}" >> /tmp/network_log
done
for key in \${physical_interfaces[@]}; do
    eval "logical_interface=\\${physical_interface_mapping_\${key}}"
    echo "map physical interface \${key} to logical interface \${logical_interface}" >> /tmp/network_log
done

declare -a unset_logical_interfaces
unset_logical_interfaces=()
declare -a unset_physical_interfaces
unset_physical_interfaces=()

echo "get unset logical interfaces from \${logical_interfaces[@]}" >> /tmp/network_log
for logical_interface in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${logical_interface}}"
    if [ ! -z "\${physical_interface}" ]; then
        echo "logical interface \${logical_interface} is already set to \${physical_interface}" >> /tmp/network_log
        continue
    fi
    unset_logical_interfaces+=(\${logical_interface})
done
echo "got unset logical interfaces: \${unset_logical_interfaces[@]}" >> /tmp/network_log

echo "get unset physical interfaces from \${physical_interfaces[@]}" >> /tmp/network_log
for physical_interface in \${physical_interfaces[@]}; do
    eval "logical_interface=\\${physical_interface_mapping_\${physical_interface}}"
    if [ ! -z "\${logical_interface}" ]; then
        echo "physical interface \${physical_interface} is already set to \${logical_interface}" >> /tmp/network_log
        continue
    fi
    unset_physical_interfaces+=(\${physical_interface})
    eval "unset_physical_interface_\${physical_interface}=\${physical_interface}"
done
echo "got unset physical interfaces: \${unset_physical_interfaces[@]}" >> /tmp/network_log

sorted_unset_physical_interfaces=(\$(printf '%s\n' \${unset_physical_interfaces[@]} | sort))
echo "sorted unset physical interfaces: \${sorted_unset_physical_interfaces[@]}" >> /tmp/network_log
sorted_unset_logical_interfaces=(\$(printf '%s\n' \${unset_logical_interfaces[@]} | sort))
echo "sorted unset logical interfaces: \${sorted_unset_logical_interfaces[@]}" >> /tmp/network_log

# map unset logical interface to unset physical interface
echo "map unset logical interfaces \${sorted_unset_logical_interfaces[@]} to unset physical interfaces \${sorted_unset_physical_interfaces[@]}" >> /tmp/network_log
while [ \${#sorted_unset_physical_interfaces[@]} -gt 0 -a \${#sorted_unset_logical_interfaces[@]} -gt 0 ]; do
    physical_interface=\${sorted_unset_physical_interfaces[0]}
    logical_interface=\${sorted_unset_logical_interfaces[0]}
    echo "map unset logical interface \${logical_interface} to unset physical interface \${physical_interface}" >> /tmp/network_log
    unset sorted_unset_physical_interfaces[0]
    unset sorted_unset_logical_interfaces[0]
    echo "map unset logical interface \${logical_interface} to unset physical interface \${physical_interface}" >> /tmp/network_log
    eval "physical_interface_mapping_\${physical_interface}=\${logical_interface}"
    eval "logical_interface_mapping_\${logical_interface}=\${physical_interface}"
done
unset_logical_interfaces=()
unset_physical_interfaces=()

echo "finish mapping unmapped logical interfaces in network config to unmapped physical interfaces" >> /tmp/network_log
for key in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${key}}"
    echo "map logical interface \${key} to physical interface \${physical_interface}" >> /tmp/network_log
done
for key in \${physical_interfaces[@]}; do
    eval "logical_interface=\\${physical_interface_mapping_\${key}}"
    echo "map physical interface \${key} to logical interface \${logical_interface}" >> /tmp/network_log
done

echo "unset logical interfaces: \${sorted_unset_logical_interfaces[@]}" >> /tmp/network_log
echo "unset physical interfaces: \${sorted_unset_physical_interfaces[@]}" >> /tmp/network_log

# map remaining unmapped logical interfaces
echo "map remaining unmapped logical interfaces" >> /tmp/network_log
if [ \${#sorted_unset_logical_interfaces[@]} -gt 0 ]; then
    declare -a available_logical_interfaces
    available_logical_interfaces=()
    # get all available logical interfaces which the same name physical interface is not used
    for logical_interface in \${logical_interfaces[@]}; do
        eval "mapped_logical_interface=\\${physical_interface_mapping_\${logical_interface}}"
	if [ -z "\${mapped_logical_interface}" ]; then
            eval "available_logical_interface_\${logical_interface}=\${logical_interface}"
	    available_logical_interfaces+=(\${logical_interface})
	else
	    echo "ignore logical interface \${logical_interface} since the same name physical interface mapped to logical interface \${mapped_logical_interface}" >> /tmp/network_log
	fi
    done

    # add extra logical interfaces name to physical interfaces
    physical_interfaces+=(\${available_logical_interfaces[@]})
    echo "updated physical interfaces: \${physical_interfaces[@]}" >> /tmp/network_log

    #first map logical interface to the same name physical interface if that physical interface name is not used
    unset_logical_interfaces=()
    for logical_interface in \${sorted_unset_logical_interfaces[@]}; do
        eval "available_logical_interface=\\${available_logical_interface_\${logical_interface}}"
	if [ ! -z "\${available_logical_interface}" ]; then
            eval "physical_interface_mapping_\${available_logical_interface}=\${logical_interface}"
            eval "logical_interface_mapping_\${logical_interface}=\${available_logical_interface}"
        else
            unset_logical_interfaces+=(\${logical_interface})
	fi
    done
    sorted_unset_logical_interfaces=(\${unset_logical_interfaces[@]})

    echo "finish mapping ramaining unmapped logical interfaces to the same name physical interface" >> /tmp/network_log
    for key in \${logical_interfaces}; do
        eval "physical_interface=\\${logical_interface_mapping_\${key}}"
        echo "map logical interface \${key} to physical interface \${physical_interface}" >> /tmp/network_log
    done
    for key in \${physical_interfaces}; do
        eval "logical_interface=\\${physical_interface_mapping_\${key}}"
        echo "map physical interface \${key} to logical interface \${logical_interface}" >> /tmp/network_log
    done
    echo "unset physical interfaces \${sorted_unset_physical_interfaces[@]}" >> /tmp/network_log
    echo "unset logical interfaces \${sorted_unset_logical_interfaces[@]}" >> /tmp/network_log

    # map remain unset logical interfaces to available logical interface names
    for logical_interface in \${sorted_unset_logical_interfaces[@]}; do
        for available_logical_interface in \${available_logical_interfaces[@}}; do
	    eval "mapped_logical_interface=\\${physical_interface_mapping_\${available_logical_interface}}"
	    if [ -z "\${mapped_logical_interface}" ]; then
	        eval "physical_interface_mapping_\${available_logical_interface}=\${logical_interface}"
		eval "logical_interface_mapping_\${logical_interface}=\${available_logical_interface}"
	        break
	    fi
	done
    done
fi
unset_logical_interfaces=()
sorted_unset_logical_interfaces=()

echo "finish mapping ramaining unmapped logical interfaces" >> /tmp/network_log
for key in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${key}}"
    echo "map logical interface \${key} to physical interface \${physical_interface}" >> /tmp/network_log
done
for key in \${physical_interfaces[@]}; do
    eval "logical_interface=\\${physical_interface_mapping_\${key}}"
    echo "map physical interface \${key} to logical interface \${logical_interface}" >> /tmp/network_log
done

# map remaining unmapped physical interfaces
echo "map remaining unmapped physical interfaces" >> /tmp/network_log
if [ \${#sorted_unset_physical_interfaces[@]} -gt 0 ]; then
    declare -a available_physical_interfaces
    available_physical_interfaces=()
    # get all available physical interfaces which the same name logical interface is not used
    for physical_interface in \${physical_interfaces[@]}; do
        eval "mapped_physical_interface=\\${logical_interface_mapping_\${physical_interface}}"
	if [ -z "\${mapped_physical_interface}" ]; then
            eval "available_physical_interface_\${physical_interface}=\${physical_interface}"
	    available_physical_interfaces+=(\${physical_interface})
	else
	    echo "ignore physical interface \${physical_interface} since the same name logical interface mapped to physical interface \${mapped_physical_interface}" >> /tmp/network_log
	fi
    done

    logical_interfaces+=(\${available_physical_interfaces[@]})
    echo "updated logical interfaces: \${logical_interfaces[@]}" >> /tmp/network_log

    #first map physical interface to the same name logical interface if that logical interface name is not used
    unset_physical_interfaces=()
    for physical_interface in \${sorted_unset_physical_interfaces[@]}; do
        eval "available_physical_interface=\\${available_physical_interface_\${physical_interface}}"
	if [ ! -z "\${available_physical_interface}" ]; then
            eval "logical_interface_mapping_\${available_physical_interface}=\${physical_interface}"
            eval "physical_interface_mapping_\${physical_interface}=\${available_physical_interface}"
        else
            unset_physical_interfaces+=(\${physical_interface})
	fi
    done
    sorted_unset_physical_interfaces=(\${unset_physical_interfaces[@]})

    # map remain unset physical interfaces to logical interface name as available physical interface names
    for physical_interface in \${sorted_unset_physical_interfaces}; do
        for available_physical_interface in \${available_physical_interfaces}; do
	    eval "mapped_physical_interface=\\${logical_interface_mapping_\${available_physical_interface}}"
	    if [ -z "\${mapped_physical_interface}" ]; then
	        eval "logical_interface_mapping_\${available_physical_interface}=\${physical_interface}"
		eval "physical_interface_mapping_\${physical_interface}=\${available_physical_interface}"
	        break
	    fi
	done
    done
fi
unset_physical_interfaces=()
sorted_unset_physical_interfaces=()

echo "finish mapping remaining unmapped physical interfaces" >> /tmp/network_log
for key in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${key}}"
    echo "map logical interface \${key} to physical interface \${physical_interface}" >> /tmp/network_log
done
for key in \${physical_interfaces[@]}; do
    eval "logical_interface=\\${physical_interface_mapping_\${key}}"
    echo "map physical interface \${key} to logical interface \${logical_interface}" >> /tmp/network_log
done

# generate udev network rules
#if $osversion == "rhel7"
udev_network_rule_filename=80-net-name-slot.rules
#else
udev_network_rule_filename=70-persistent-net.rules
#end if
for key in \${logical_interfaces[@]}; do
    eval "physical_interface=\\${logical_interface_mapping_\${key}}"
    if [ ! -z "\${physical_interface}" ]; then
        eval "physical_mac=\\${physical_interface_mac_\${physical_interface}}"
    else
        physical_mac=""
    fi
    if [ ! -z "\${physical_mac}" ]; then
        physical_mac=\$(echo \$physical_mac | tr 'A-Z' 'a-z')
        echo "SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR{address}==\"\${physical_mac}\", ATTR{type}==\"1\", KERNEL==\"eth*\", NAME=\"\$key\"" >> /etc/udev/rules.d/\${udev_network_rule_filename}.new
	echo "add network interface \$key mac \$physical_mac into udev rules" >> /tmp/network_log
    else
        echo "network interface \$key does not find mac address to add to udev rules" >> /tmp/network_log
    fi
done

#if $numbondingdevs > 0
# we have bonded interfaces, so set max_bonds
if [ -f "/etc/modprobe.conf" ]; then
    echo "options bonding max_bonds=$numbondingdevs" >> /etc/modprobe.conf
fi
#end if

# create a working directory for interface scripts
mkdir /etc/sysconfig/network/cobbler
cp /etc/sysconfig/network/ifcfg-lo /etc/sysconfig/network/cobbler/


#set $nameserver_set = 0

#for $iname in $ikeys
# Start configuration for $iname
    ## create lots of variables to use later
    #set $idata                = $interfaces[$iname]
    #set $mac                  = $idata.get("mac_address", "").upper()
    #set $mtu                  = $idata.get("mtu", "")
    #set $static               = $idata.get("static", "")
    #set $ip                   = $idata.get("ip_address", "")
    #set $netmask              = $idata.get("netmask", "")
    #set $if_gateway           = $idata.get("if_gateway", "")
    #set $static_routes        = $idata.get("static_routes", "")
    #set $iface_type           = $idata.get("interface_type", "").lower()
    #set $iface_master         = $idata.get("interface_master", "")
    #set $bonding_opts         = $idata.get("bonding_opts", "")
    #set $bridge_opts          = $idata.get("bridge_opts", "").split(" ")
    #set $devfile              = "/etc/sysconfig/network/cobbler/ifcfg-" + $iname
    #set $routesfile           = "/etc/sysconfig/network/cobbler/ifroute-" + $iname

used_logical_interface_$iname=$iname

    #if $iface_type in ("slave","bond_slave","bridge_slave","bonded_bridge_slave")
        #set $static = 0
    #end if

echo "NAME='$iname'" > $devfile
echo "USERCONTROL='no'" >> $devfile

    #if $iface_type not in ("master","bond","bridge","bonded_bridge_slave")
        #if $vlanpattern.match($iname)
            #pass
        #else
            #set $interface_matched = $subinterfacepattern.match($iname)
            #if $interface_matched
                #set $interface_name = $interface_matched.group(1)
logical_interface=$interface_name
            #else
logical_interface=$iname
            #end if
eval "physical_interface=\\${logical_interface_mapping_\${logical_interface}}"
if [ ! -z "\${physical_interface}" ]; then
    eval "physical_mac=\\${physical_interface_mac_\${physical_interface}}"
fi
if [ ! -z "\${physical_mac}" ]; then
    physical_mac=\$(echo \${physical_mac} | tr 'A-Z' 'a-z')
    echo "LLADDR='\${physical_mac}'" >> $devfile
fi
            #if not $subinterfacepattern.match($iname)
if [ -f "/etc/modprobe.conf" ] && [ ! -z "\${physical_interface}" ]; then
    grep \$physical_interface /etc/modprobe.conf | sed "s/\${physical_interface}/$iname/" >> /etc/modprobe.conf.cobbler
    grep -v \$physical_interface /etc/modprobe.conf >> /etc/modprobe.conf.new
    rm -f /etc/modprobe.conf
    mv -f /etc/modprobe.conf.new /etc/modprobe.conf
fi
            #end if
        #end if
    #end if

    #if $iface_type in ("master","bond","bonded_bridge_slave")
        ## if this is a bonded interface, configure it in modprobe.conf
if [ -f "/etc/modprobe.conf" ]; then
        #if $osversion == "rhel4"
    echo "install $iname /sbin/modprobe bonding -o $iname $bonding_opts" >> /etc/modprobe.conf.cobbler
        #else
    echo "alias $iname bonding" >> /etc/modprobe.conf.cobbler
        #end if
fi
        #if $bonding_opts != ""
echo "BONDING_MODULE_OPTS='$bonding_opts'" >> $devfile
        #end if
echo "BONDING_MASTER='yes'" >> $devfile

        #set $loop_ikeys = $interfaces.keys()
        #set $loop_counter = 0
        #for $loop_iface in $loop_ikeys
          #set $loop_idata          = $interfaces[$loop_iface]
          #set $loop_interface_type = $loop_idata["interface_type"]
          #if $loop_interface_type.lower == "bond_slave"
             #if $loop_idata["interface_master"] != ""
                #if $loop_idata["interface_master"].lower() == $iface.lower()
echo "BONDING_SLAVE_$loop_counter='$loop_iface'" >> $devfile
                   #set $loop_counter += 1
                #end if
             #end if
          #end if
        #end for
    #end if

    #if $iface_type == "bridge"
echo "BRIDGE='yes'" >> $devfile
echo "BRIDGE_STP='on'" >> $devfile
echo "BRIDGE_PORTS='$iface_master'" >> $devfile
        #set $bridgeslaves = ""
        #for $bridgeiname in $ikeys
            #set $bridgeidata                = $interfaces[$bridgeiname]
            #set $bridgeiface_type           = $bridgeidata.get("interface_type", "").lower()
            #set $bridgeiface_master         = $bridgeidata.get("interface_master", "")
            #if $bridgeiface_master == $iname
                #set $bridgeslaves += $bridgeiname + " "
            #end if
        #end for
echo "BRIDGE_PORTS='$bridgeslaves'" >> $devfile
    #end if

    #if $static
echo "BOOTPROTO='static'" >> $devfile
echo "STARTMODE='onboot'" >> $devfile
        #if $iname in $promisc_interfaces
echo 'LINK_OPTIONS="promisc on"' >> $devfile
        #elif $ip != ""
echo "IPADDR='$ip'" >> $devfile

            #if $netmask == ""
	        ## Default to 255.255.255.0?
                #set $netmask = "255.255.255.0"
            #end if
echo "NETMASK='$netmask'" >> $devfile
        #end if
    #elif $static == ""
echo "BOOTPROTO='dhcp'" >> $devfile
    #else
echo "BOOTPROTO='none'" >> $devfile
echo "STARTMODE='hotplug'" >> $devfile
    #end if

    #if $mtu != ""
echo "MTU='$mtu'" >> $devfile
    #end if

    #for $route in $static_routes
        #set routepattern = $re.compile("[0-9/.]+:[0-9.]+")
        #if $routepattern.match($route)
            #set $routebits = $route.split(":")
            #set [$network, $router] = $route.split(":")
echo "$network $router $iname" >> $routesfile
        #else
# Warning: invalid route "$route"
        #end if
    #end for
#end for

for logical_interface in \${logical_interfaces[@]}; do
    eval "used_logical_interface=\\${used_logical_interface_\${logical_interface}}"
    if [ ! -z "\${used_logical_interface}" ]; then
        # ignore logical interface that is already generated in above
        echo "ignore used logical interface \${logical_interface}" >> /tmp/network_log
        continue
    fi
    echo "add logical interface \${logical_interface} into network config since it is not set above" >> /tmp/network_log
    eval "physical_interface=\\${logical_interface_mapping_\${logical_interface}}"
    if [ ! -z "\${physical_interface}" ]; then
        eval "devfile=/etc/sysconfig/network/cobbler/ifcfg-\${logical_interface}"
        eval "routesfile=/etc/sysconfig/network/cobbler/ifroute-\${logical_interface}"
        eval "mac=\\${physical_interface_mac_\${physical_interface}}"
        echo "NAME='\${logical_interface}'" > \$devfile
        echo "STARTMODE='onboot'" >> \$devfile
        echo "USERCONTROL='no'" >> \$devfile
        echo "BOOTPROTO='static'" >> \$devfile
        if [ ! -z "\$mac" ]; then
            mac=\$(echo \${mac} | tr 'A-Z' 'a-z')
            echo "LLADDR='\${mac}'" >> \$devfile
        fi

        if [ -f "/etc/modprobe.conf" ] && [ ! -z "\${physical_interface}" ]; then
            grep \${physical_interface} /etc/modprobe.conf | sed "s/\${physical_interface}/\${logical_interface}/" >> /etc/modprobe.conf.cobbler
            grep -v \${physical_interface} /etc/modprobe.conf >> /etc/modprobe.conf.new
            rm -f /etc/modprobe.conf
            mv -f /etc/modprobe.conf.new /etc/modprobe.conf
        fi
    fi
done

## Move all staged files to their final location
rm -f /etc/sysconfig/network/ifcfg-*
mv -f /etc/sysconfig/network/cobbler/* /etc/sysconfig/network/
rm -r /etc/sysconfig/network/cobbler
if [ -f "/etc/modprobe.conf" ]; then
    cat /etc/modprobe.conf.cobbler >> /etc/modprobe.conf
    rm -f /etc/modprobe.conf.cobbler
fi
if [ -f "/etc/udev/rules.d/\${udev_network_rule_filename}" ]; then
    rm -f /etc/udev/rules.d/\${udev_network_rule_filename}
fi

if [ -f "/etc/udev/rules.d/\${udev_network_rule_filename}.new" ]; then
    mv -f /etc/udev/rules.d/\${udev_network_rule_filename}.new /etc/udev/rules.d/\${udev_network_rule_filename}
fi
# End post_install_network_config generated code
